# 多线程高频面试考点
### 怎么保证线程同步
- [很详细](https://blog.csdn.net/yuqing2015/article/details/82788041?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.baidujs&dist_request_id=1328642.38542.16157091267591879&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.baidujs)
### Volatile关键字的作用和实现
- 保证可见性
- 不保证原子性
- 避免指令重排(内存屏障) 再Volatile写的前后加锁避免指令重排
[讲解的很详细](https://blog.csdn.net/zzti_erlie/article/details/86355477)
### Volatile怎么保证原子性
- 加Lock锁，Synchronized锁。
- 使用原子类，解决原子性问题(AtomicInteger)
### 聊聊线程池你知道多少
- **为什么用线程池**
    - 降低资源消耗。提高线程利用率，降低创建和销毁线程的消耗。
    - 提高响应速度。任务来了，直接有线程可用可执行，而不是先创建线程再执行。
    - 提高线程的可管理性。线程是稀缺资源，使用线程池可以统一分配调优监控。
- **创建线程的4大方法**
    - Executors.newSingleThreadExecutor() 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。
    - Executors.newFixedThreadPool()      创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。
    - Executors.newCachedThreadPool()     创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。
    - Executors.newScheduledThreadPool()  创建一个定长线程池，支持定时及周期性任务执行。
    - newSingleThreadExecutor() newFixedThreadPool() 默认阻塞队列LinkedBlockingQueue(capacity: Integer.MAX_VALUE(21_4748_3647)) 可能会堆积大量请求，导致OOM。
    - newCachedThreadPool() newScheduledThreadPool() 默认允许创建的最大线程数为Integer.MAX_VALUE(21_4748_3647)，可能会创建大量的线程，导致OOM。
    - OOM：Out Of Memory 内存用完了。
- **线程池的7大参数**
    - int corePoolSize：核心线程数
    - int maximumPoolSize：最大线程数
    - long keepAliveTime、TimeUnit unit：如果创建了核心线程数之外的线程，当超过指定时间后线程将会被回收。  超时单位。
    - BlockingQueue<Runnable> workQueue：阻塞队列。
    - ThreadFactory threadFactory：线程工厂用来创建线程，可以自定义创建的方法。
    - RejectedExecutionHandler handle：拒绝策略。
    - 当来任务的时候，会使用核心线程来完成任务。当核心线程都在被使用的时候，再来任务将会被放入阻塞队列中等待。当阻塞队列也满了的时候并且核心线程的工作还没有结束将会创建临时线程直到到达最大线程数。若到达最大线程数还有任务则会触发拒绝策略。
- **4种拒绝策略**
    - new ThreadPoolExecutor.AbortPolicy()**默认**  丢弃任务并抛出RejectedExecutionException异常。
    - new ThreadPoolExecutor.CallerRunsPolicy()    由提交任务的当前线程处理。
    - new ThreadPoolExecutor.DiscardPolicy()       悄无声息丢弃任务，但是不抛出异常。
    - new ThreadPoolExecutor.DiscardOldestPolicy() 悄无声息丢弃最老的任务，也不会抛出异常。
- **为什么先放进阻塞队列而不是先创建最大线程**
  - 在创建新线程的时候是要获取全局锁的，这个时候其他的线程就得阻塞，影响了整体效率。
---
### CountDownLatch CyclicBarrier Semaphore
- CountDownLatch(不能重复利用)
  - 它是一个同步辅助器，允许一个或多个线程一直等待，直到一组在其他线程执行的操作全部完成。
  - 比如线上出现bug，领导焦急的过来，想找人迅速的解决这个 bug 。一个人解决肯定速度慢啊，于是叫来张三和李四，一起分工解决。终于，当他们两个都做完了自己所需要做的任务之后，领导才可以答复客户，客户也就消气了。领导线程需要等到两个员工线程修复bug之后才能答复客户。
  - 底层：private volatile int state    AQS
- CyclicBarrier(循环利用)
  - 一组线程会互相等待，直到所有线程都到达一个同步点。这个就非常有意思了，就像一群人被困到了一个栅栏前面，只有等最后一个人到达之后，他们才可以合力把栅栏（屏障）突破。
  - 现在模拟一个常用的场景，一组运动员比赛 1000 米，只有在所有人都准备完成之后，才可以一起开跑。
- Semaphore
  - Semaphore 信号量，用来控制同一时间，资源可被访问的线程数量，一般可用于流量的控制。
  - 现在有 20 辆车要通过这个地段， 警察叔叔规定同一时间，最多只能通过 5 辆车，其他车辆只能等待。只有拿到许可的车辆可通过，等车辆通过之后，再归还许可，然后把它发给等待的车辆，获得许可的车辆再通行，依次类推。
> - CountDownLatch 是一个线程等待其他线程， CyclicBarrier 是多个线程互相等待。
> - CountDownLatch 的计数是减 1 直到 0，CyclicBarrier 是加 1，直到指定值。
> - CountDownLatch 是一次性的， CyclicBarrier  可以循环利用。
> - CyclicBarrier 可以在最后一个线程达到屏障之前，选择先执行一个操作。
> - Semaphore ，需要拿到许可才能执行，并可以选择公平和非公平模式。