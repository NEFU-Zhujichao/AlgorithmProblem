# 计算机网络面经
[字节后端面经有很多计网和操作系统](https://www.nowcoder.com/discuss/619628)
### 运输层总结
- 运输层的一个很重要的功能就是复用和分用。应用层不同进程的报文通过不同的端口向下交到运输层，再往下就共用网络层提供的服务。
- TCP传送的数据单位协议是**TCP报文段。**UDP传送的数据单位协议是**UDP报文或用户数据报。**
### TCP/UDP区别
> UDP：对网络通讯质量要求不高时，要求网络通讯速度要快的场景
  - 无连接，发送数据之前不需要建立连接。
  - 尽最大努力交付，不保证可靠交付，不使用拥塞控制。
  - 面向报文，适合多媒体通信。
  - 支持一对一，一对多，多对一，多对多的交互通信。
  - 首部开销小，8个字节。
> TCP：当对网络通讯质量有要求时，比如HTTP、HTTPS、FTP等传输文件的协议， POP3、SMTP等邮件传输的协议
  - 面向连接。
  - 每一条TCP有且只有两个端点，为一对一关系。
  - 提供可靠交付。
  - 全双工通信，全双工为即可传输又可接收。
  - 面向字节流。
### TCP为什么可靠
[TCP为什么可靠](https://zhuanlan.zhihu.com/p/130730913)
- 乱序重排
- 应答确认
- 报文重传
- 流量控制
- 拥塞控制
### TCP重传机制、流量控制、滑动窗口、拥塞控制
![](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeuicRMlA8rKvl5AVLibhibDhgTfasBzdn2sIB39aFcqL22zhAa7v9d9vR1oZF4mibLUKouDEfKjYoZww/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1) 
> 重传机制
- TCP 实现可靠传输的方式之一，是通过序列号与确认应答。TCP 针对数据包丢失的情况，会用**重传机制**解决。
  - 超时重传：在发送数据时，设定一个定时器，当超过指定的时间后，没有收到对方的 ACK 确认应答报文，就会重发该数据
  - 快速重传：快速重传的工作方式是当收到三个相同的 ACK 报文时，会在定时器过期之前，重传丢失的报文段。
  - SACK：这种方式需要在 TCP 头部「选项」字段里加一个 SACK 的东西，它可以将缓存的地图发送给发送方，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以只重传丢失的数据。
  - D-SACK：使用了 SACK 来告诉「发送方」有哪些数据被重复接收了。
> 流量控制：流量控制是避免「发送方」的数据填满「接收方」的缓存，但是并不知道网络的中发生了什么。
- 发送方不能无脑的发数据给接收方，要考虑接收方处理能力。如果一直无脑的发数据给对方，但对方处理不过来，那么就会导致触发重发机制，从而导致网络流量的无端的浪费。为了解决这种现象发生，TCP 提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量，这就是所谓的流量控制。
- 糊涂窗口综合症的现象是可以发生在发送方和接收方：
  - 接收方可以通告一个小的窗口
  - 而发送方可以发送小数据
> 拥塞控制：是避免「发送方」的数据填满整个网络。
- 为了在「发送方」调节所要发送数据的量，定义了一个叫做「拥塞窗口」的概念。拥塞窗口cwnd是发送方维护的一个的状态变量，它会根据网络的拥塞程度动态变化的。我们在前面提到过发送窗口 swnd 和接收窗口 rwnd 是约等于的关系，那么由于入了拥塞窗口的概念后，**此时发送窗口的值是swnd = min(cwnd, rwnd)，也就是拥塞窗口和接收窗口中的最小值。**
- 拥塞控制主要是四个算法：
  - 慢启动：慢启动算法中cwnd的大小呈指数趋势上涨。 
    - 有一个叫慢启动门限  ssthresh （slow start threshold）状态变量。
    - 当 cwnd < ssthresh 时，使用慢启动算法
    - 当 cwnd >= ssthresh 时，就会使用「拥塞避免算法」
  - 拥塞避免：拥塞避免算法中cwnd的大小呈线性增长。
  - 拥塞发生：当网络出现拥塞，也就是会发生数据包重传。
    - 这两种使用的拥塞发生算法是不同的，接下来分别来说说。
    - 超时重传：1.ssthresh 设为 cwnd/2  2.cwnd 重置为 1。接着，就重新开始慢启动，慢启动是会突然减少数据流的。这真是一旦「超时重传」，马上回到解放前。但是这种方式太激进了，反应也很强烈，会造成网络卡顿。
![](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeuicRMlA8rKvl5AVLibhibDhgDicBugvroe9EtiaFU38hk4JuVfDciauVPfecBNp8TPI1zkoqbibePA4dlg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1) 
    - 快速重传：1.cwnd = cwnd/2 ，也就是设置为原来的一半  2.ssthresh = cwnd 3.进入快速恢复算法
  - 快速恢复：快速重传和快速恢复算法一般同时使用，快速恢复算法是认为，你还能收到 3 个重复 ACK 说明网络也不那么糟糕，所以没有必要像 RTO 超时那么强烈。
    - 拥塞窗口 cwnd = ssthresh + 3
    - 重传丢失的数据包
    - 如果再收到重复的 ACK，那么 cwnd 增加 1
    - 如果收到新数据的 ACK 后，设置 cwnd 为 ssthresh，接着就进入了拥塞避免算法。 也就是没有像「超时重传」一夜回到解放前，而是还在比较高的值，后续呈线性增长。
![](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeuicRMlA8rKvl5AVLibhibDhgR3w50EdpWF95ZM6QPpELCF3P1niazia8nBrSQUvX7e7F7LXMiaXR3iayUA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)
### TCP(传输控制协议)3次握手，为什么不能是2次握手？4次握手？
![](https://uploadfiles.nowcoder.com/images/20210321/359311331_1616293971851/0FB4D2D907EBCFCABED69AB763D161F6)  
- 三次握手。
- 为什么不是2次？
  - 主要是为了防止已失效的请求连接报文忽然又传送到了，从而产生错误。假定A向B发送一个连接请求，由于一些原因，导致A发出的连接请求在一个网络节点逗留了比较多的时间。此时A会将此连接请求作为无效处理。又重新向B发起了一次新的连接请求，B正常收到此连接请求后建立了连接，数据传输完成后释放了连接。**如果此时A发出的第一次请求又到达了B，B会以为A又发起了一次连接请求，如果是两次握手，此时连接就建立了，B会一直等待A发送数据，从而白白浪费B的资源。** 如果是三次握手：由于A没有发起连接请求，也就不会理会B的连接响应，B没有收到A的确认连接，就会关闭掉本次连接。
  - 同时也不能保证传输的可靠性。
- 为什么不是4次？
  - 理论上讲不论握手多少次都不能确认一条信道是“可靠”的，但通过3次握手可以至少确认它是“可用”的，再往上加握手次数不过是提高“它是可用的”这个结论的可信程度。
  - 避免资源浪费。
- 三次握手本质：
  - 本质：1、保证信道数据传输的可靠性；2、避免资源浪费 3、三次是保证双方互相明确对方能收能发的最低值。
  - TCP 的可靠连接是靠 seq（ sequence numbers 序列号）来达成的。
### TCP4次挥手，为什么等2MLS？ Maximum Segment Lifetime 报文最大生存时间
![](https://uploadfiles.nowcoder.com/images/20210321/359311331_1616293986041/1824ADE63A3CABCA9C660BA09C1DA1C8)  
- 四次挥手。
1. 为了保证 A 发送的最后一个 ACK 报文段能够到达 B。
2. 防止 “已失效的连接请求报文段”出现在下次连接中。A 在发送完最后一个 ACK 报文段后，再经过时间 2MSL，就可以使本连接持续的时间内所产生的所有报文段，都从网络中消失。这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。
### https详解
- HTTPS是身披TLS/SSL外壳的HTTP。HTTPS是一种通过计算机网络进行安全通信的传输协议，经由HTTP进行通信，利用SSL/TLS建立全信道，加密数据包。HTTPS使用的主要目的是提供对网站服务器的身份认证，同时保护交换数据的隐私与完整性。  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/VMORHafhQIMVgicZXOeicEJscQFXU3y2ibpuVYnibFtWRHyE2TXYlsS8oZiaQbK6cia4ic310qicVxlpPXgj3TP0q2mxpA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1) 
#### 步骤
1. 用户在浏览器发起HTTPS请求(如 https://www.mogu.com/)，默认使用服务端的443端口进行连接；
2. HTTPS需要使用一套CA数字证书，证书内会附带一个公钥Pub，而与之对应的私钥Private保留在服务端不公开；
3. 服务端收到请求，返回配置好的包含公钥Pub的证书给客户端；
4. 客户端收到证书，校验合法性，主要包括是否在有效期内、证书的域名与请求的域名是否匹配，上一级证书是否有效（递归判断，直到判断到系统内置或浏览器配置好的根证书），如果不通过，则显示HTTPS警告信息，如果通过则继续；
5. 客户端生成一个用于对称加密的随机Key，并用证书内的公钥Pub进行加密，发送给服务端；
6. 服务端收到随机Key的密文，使用与公钥Pub配对的私钥Private进行解密，得到客户端真正想发送的随机Key；
7. 服务端使用客户端发送过来的随机Key对要传输的HTTP数据进行对称加密，将密文返回客户端；
8. 客户端使用随机Key对称解密密文，得到HTTP数据明文；
9. 后续HTTPS请求使用之前交换好的随机Key进行对称加解密。
- 内容加密：采用混合加密技术，中间者无法直接查看明文内容
- 验证身份：通过返回的CA数字证书认证客户端访问的服务器是否正规
- 保护数据完整性：防止传输的内容被中间人冒充或者篡改
> - **混合加密**：结合非对称加密和对称加密技术。客户端使用对称加密生成密钥对传输数据进行加密，然后使用非对称加密的公钥再对秘钥进行加密，所以网络上传输的数据是被秘钥加密的密文和用公钥加密后的秘密秘钥，因此即使被黑客截取，由于没有私钥，无法获取到加密明文的秘钥，便无法获取到明文数据。
> - **数字摘要**：通过单向hash函数对原文进行哈希，将需加密的明文“摘要”成一串固定长度(如128bit)的密文，不同的明文摘要成的密文其结果总是不相同，同样的明文其摘要必定一致，并且即使知道了摘要也不能反推出明文。
> - **数字签名技术**：数字签名建立在公钥加密体制基础上，是公钥加密技术的另一类应用。它把公钥加密技术和数字摘要结合起来，形成了实用的数字签名技术。
- **非对称加密过程需要用到公钥进行加密，那么公钥从何而来？其实公钥就被包含在数字证书中，数字证书通常来说是由受信任的数字证书颁发机构CA，在验证服务器身份后颁发，证书中包含了一个密钥对（公钥和私钥）和所有者识别信息。数字证书被放到服务端，具有服务器身份验证和数据传输加密功能。**
### get post 区别
1. get用于请求服务器返回资源，post一般用于表单的提交。
2. get方法请求参数会拼接在URL上不安全。post方法请求参数放在**请求体body中。**
3. get请求URL有长度限制，post对长度无要求。
4. get请求会被浏览器主动cache，post不会，除非手动设置。
5. get请求在浏览器反复的 回退/前进 操作是无害的，而post操作会再次提交表单请求。
6. **get请求在发送过程中会产生一个TCP数据包，post在发送过程中会产生两个TCP数据包。** 对于get请求，浏览器会把http header和data一并发送出去，服务器响应200；而对于post，浏览器先发送header，服务器响应100 continue,浏览器再发送data，服务器响应200 ok。
### cookie和session区别
- Cookie存放在客户端浏览器中   Session存放在服务器中。
- cookie的大小受限制，单个cookie保存的数据**不能超过4K**，很多浏览器都限制一个站点**最多保存20个cookie。**  session的大小一般不受限制。
- 工作原理：
    - 客户端将cookie把数据存在在浏览器中，这样浏览器再次请求的时候就会带上这个cookie，浏览器就认识这个请求了。客户端第一次访问服务器的时候浏览器会在响应头中加上Set-Cookie信息，当再次发送一个请求的时候，请求会在请求头上带上Cookie:xxx,也就是前面自己的数据，目的是让服务器认识自己。
    - 服务器为每一次会话创建了一块内存区域来存在数据，第一次请求服务器把数据存放在了服务器中，服务器给客户端响应一个编号，下次再来请求的时候拿着这个编号在服务器的内存空间中可以找到自己的数据。 客户端浏览器第一次请求服务器，服务器会创建cookie对象并且把数据按照key-value的形式起来，然后在响应头中加上Set-Cookie:xxx（这里的xxx其实就是sessionId）,下一次访问的时候，会在请求头中加上Cookie:xxx（实际上session是基于cookie实现的）
### 键入网址后，期间发生了什么
> 1. 浏览器做的第一步工作是解析 URL
- 对 URL 进行解析之后，浏览器确定了 Web 服务器和文件名，接下来就是根据这些信息来生成 HTTP 请求消息了。
> 2. 域名对应的真实地址查询 —— DNS服务器
- 客户端首先会发出一个 DNS 请求，问 www.server.com 的 IP 是啥，并发给本地 DNS 服务器。本地域名服务器收到客户端的请求后，如果缓存里的表格能找到 www.server.com，则它直接返回 IP 地址。如果没有，本地 DNS 会去请求它的根域名服务器。根域名服务器返回顶级域名服务器地址，向顶级域名服务器发送请求之后，顶级域名服务器会返回权限DNS服务器。权限DNS服务器查询后将对应的 IP 地址 X.X.X.X 告诉本地 DNS。
> 3. 通过协议栈中的各种协议完成数据包的填充。(TCP、UDP、IP、ICMP、ARP)
> 4. TCP三次握手：三次握手目的是保证双方都有发送和接收的能力。
> 5. 连接建立后，浏览器会通过该连接向远程服务器发送HTTP的GET请求。远程服务器找到资源并使用HTTP响应返回该资源，值为200的HTTP响应状态码表示一个正确的响应。
> 6. 此时Web服务器提供资源服务，客户端开始下载资源。浏览器解析资源去渲染页面。
> 7. 最后，客户端要离开了，向服务器发起了 TCP 四次挥手，至此双方的连接就断开了。
### DNS解析原理，使用的底层协议
> DNS解析有两种 查询方式，分为递归查询和迭代查询。一般的主机向本地域名服务器的查询使用递归查询，本地域名服务器向根域名服务器查询使用迭代查询。它使用的是UDP协议，原因是性能更好，查询时间更短，如果发生数据丢失，重传一个就好了，不需要建立连接。  
![](https://uploadfiles.nowcoder.com/images/20210321/359311331_1616290663575/17B317B17F26BB43E96386BC0DBB0A26) 
![](https://uploadfiles.nowcoder.com/images/20210321/359311331_1616290676587/FB03902D614CD1E76E642D398A1539E1)
### url的组成
协议类型://服务器地址[:端口号]/路径/文件名[参数=值]  
https://127.0.0.1:8080/api/list/1
### http状态码