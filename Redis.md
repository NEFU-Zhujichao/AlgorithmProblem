# Redis面经
> String、Hash、List、Set、ZSet、HyperLogLog、Geo、BitMap、Pub/Sub、**BloomFilter** 
> Redis采用的是基于内存的采用的是单线程模型的 KV 数据库，由C语言编写，官方提供的数据是可以达到100000+的QPS（每秒内查询次数）。
### 缓存击穿？缓存穿透？缓存雪崩
- 缓存穿透：假设这样一个场景，我们数据库中的主键是自增的，然后黑客利用大量肉鸡模拟主键为**负数**的请求，所以这些请求都会使得数据库进行一次查询，大量请求可能会把数据库直接打崩。
  #### 解决方案：
  - set空值：没查到的数据为key 值为null。但是大量的请求会导致redis数据库中存在大量的空值数据。如果说redis内存set满了，redis会进行缓存淘汰策略，导致你redis中老的值或者正在用的值被淘汰掉。一直请求redis，redis服务器的压力也不小。
  - 布隆过滤器：把数据库的部分数据在布隆过滤器中也设置一份。**布隆过滤器能够判断值一定不在里面，但是不能判断值一定在里面**。
- 缓存击穿：假设这样一个场景，一个秒杀系统中的**key**为库存量，如果库存的key突然失效了，所有的请求就都会打到MySQL中，布隆过滤器就没用了因为数据库中都有这些信息，数据库就挡不住大量的请求，容易挂掉。一般都是因为key的失效时间到了或者redis服务器挂了。 
  #### 解决方案：    
    - 不设置key的失效时间。
    - 在事故前：Redis的高可用，主从+哨兵 做redis的集群，防止redis服务器挂掉。
    - 在事故中：可能会换成第三方的缓存，本地Ehcache Hystrix限流和降级 避免MySQL被请求打死。
    - 在事故后：假如redis服务器挂了，需要持久化的rdb+aof 服务器一旦重启将会自动从磁盘上加载数据，快速恢复缓存的数据。
- 缓存雪崩：
### Redis如何设置分布式锁
> 先拿setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记了释放。**可以同时把setnx和expire合成一条指令来用的！**
### 使用过Redis做异步队列么，你是怎么用的？
- 一般使用list结构作为队列，rpush生产消息，lpop消费消息。当lpop没有消息的时候，要适当sleep一会再重试。
  - 可不可以不用sleep呢：list还有个指令叫blpop，在没有消息的时候，它会阻塞住直到消息到来。
- 能不能生产一次消费多次呢：使用pub/sub主题订阅者模式，可以实现 1:N 的消息队列。
  - pub/sub有什么缺点：在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如RocketMQ等。
### Redis是怎么持久化的
- RDB做镜像全量持久化，AOF做增量持久化。因为RDB会耗费较长时间，不够实时，在停机的时候会导致大量丢失数据，所以需要AOF来配合使用。在redis实例重启时，会使用RDB持久化文件重新构建内存，再使用AOF重放近期的操作指令来实现完整恢复重启之前的状态。
  - 如果突然机器掉电会怎样：取决于AOF日志sync属性的配置，如果不要求性能，在每条写指令时都sync一下磁盘，就不会丢失数据。但是在高性能的要求下每次都sync是不现实的，一般都使用定时sync，比如1s1次，这个时候最多就会丢失1s的数据。
> RDB的原理是什么？
- fork和cow。fork是指redis通过创建子进程来进行RDB操作，cow指的是copy on write，子进程创建后，父子进程共享数据段，父进程继续提供读写服务，写脏的页面数据会逐渐和子进程分离开来。
### Redis的同步机制
- Redis可以使用主从同步，从从同步。第一次同步时，主节点做一次bgsave，并同时将后续修改操作记录到内存buffer，待完成后将RDB文件全量同步到复制节点，复制节点接受完成后将RDB镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。后续的增量数据通过AOF日志同步即可，有点类似数据库的binlog。
### 是否使用过Redis集群，集群的高可用怎么保证，集群的原理是什么？
- Redis Sentinal 着眼于高可用，在master宕机时会自动将slave提升为master，继续提供服务。
- Redis Cluster 着眼于扩展性，在单个redis内存不足时，使用Cluster进行分片存储。
