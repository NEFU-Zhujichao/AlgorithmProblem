# MySQL面经
[MySQL](https://www.zhihu.com/people/aobingJava/posts?page=2) 
SELECT * FROM table LIMIT 5,10; //检索记录行6-15
### [深入理解 MySQL事务](https://blog.csdn.net/qq_35246620/article/details/61200815?utm_source=app&app_version=4.5.8)
### 什么是索引
官方介绍索引是帮助MySQL高效获取数据的数据结构。更通俗的说，数据库索引好比是一本书前面的目录，能加快数据库的查询速度。  
一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往是存储在磁盘上的文件中的（可能存储在单独的索引文件中，也可能和数据一起存储在数据文件中）。  
我们通常所说的索引，包括聚集索引、覆盖索引、组合索引、前缀索引、唯一索引等，没有特别说明，默认都是使用B+树结构组织（多路搜索树，并不一定是二叉的）的索引。
---
Mysql选用B+树这种数据结构作为索引，可以提高查询索引时的磁盘IO效率，并且可以提高范围查询的效率，并且B+树里的元素也是有序的。  
### 索引的优势和劣势
优势： 
- 可以提高数据检索的效率，降低数据库的IO成本，类似于书的目录。
- 通过索引列对数据进行排序，降低数据排序的成本，降低了CPU的消耗。
  - 被索引的列会自动进行排序，包括【单列索引】和【组合索引】，只是组合索引的排序要复杂一些。
  - 如果按照索引列的顺序进行排序，对应order by语句来说，效率就会提高很多。
劣势：
- 索引会占据磁盘空间
- 索引虽然会提高查询效率，但是会降低更新表的效率。比如每次对表进行增删改操作，MySQL不仅要保存数据，还要保存或者更新对应的索引文件。
### 索引类型
> 主键索引  

索引列中的值必须是唯一的，不允许有空值。
> 普通索引

MySQL中基本索引类型，没有什么限制，允许在定义索引的列中插入重复值和空值。
> 唯一索引

索引列中的值必须是唯一的，但是允许为空值。
> 全文索引

只能在文本类型CHAR,VARCHAR,TEXT类型字段上创建全文索引。字段长度比较大时，如果创建普通索引，在进行like模糊查询时效率比较低，这时可以创建全文索引。MyISAM和InnoDB中都可以使用全文索引。
> 空间索引

MySQL在5.7之后的版本支持了空间索引，而且支持OpenGIS几何数据模型。MySQL在空间索引这方面遵循OpenGIS几何数据模型规则。 一般不用，因为有更好的搜索引擎，ES。
> 前缀索引

在文本类型如CHAR,VARCHAR,TEXT类列上创建索引时，可以指定索引列的长度，但是数值类型不能指定。
> 其他（按照索引列数量分类）
1. 单列索引
2. 组合索引  
组合索引的使用，需要遵循最左前缀匹配原则（最左匹配原则）。一般情况下在条件允许的情况下使用组合索引替代多个单列索引使用。
### 索引的数据结构
> Hash表

Hash表，在Java中的HashMap，TreeMap就是Hash表结构，以键值对的方式存储数据。我们使用Hash表存储表数据Key可以存储索引列，Value可以存储行记录或者行磁盘地址。**Hash表在等值查询时效率很高，时间复杂度为O(1)；但是不支持范围快速查找，范围查找时还是只能通过扫描全表方式。**  
**显然这种并不适合作为经常需要查找和范围查找的数据库索引使用。**

### 要创建出好的索引要顾及到很多的方面
- 最左前缀匹配原则。这是非常重要、非常重要、非常重要（重要的事情说三遍）的原则，MySQL会一直向右匹配直到遇到范围查询 （>,<,BETWEEN,LIKE）就停止匹配。
- 尽量选择区分度高的列作为索引，区分度的公式是 COUNT(DISTINCT col)/COUNT(*)。表示字段不重复的比率，比率越大我们扫描的记录数就越少。
- 索引列不能参与计算，尽量保持列“干净”。比如， FROM_UNIXTIME(create_time)='2016-06-06' 就不能使用索引，原因很简单，B+树中存储的都是数据表中的字段值，但是进行检索时，需要把所有元素都应用函数才能比较，显然这样的代价太大。所以语句要写成 ：create_time=UNIX_TIMESTAMP('2016-06-06')。
- 尽可能的扩展索引，不要新建立索引。比如表中已经有了a的索引，现在要加（a,b）的索引，那么只需要修改原来的索引即可。
- 单个多列组合索引和多个单列索引的检索查询效果不同。在MySQL5.0以后的版本中，有“合并索引”的策略，翻看了《高性能MySQL 第三版》，书作者认为：还是应该建立起比较好的索引，而不应该依赖于“合并索引”这么一个策略。
- “合并索引”策略简单来讲，就是使用多个单列索引，然后将这些结果用“union或者and”来合并起来。
### MySQL执行计划怎么看？
[click](https://nyimac.gitee.io/2020/08/16/MySQL%E9%AB%98%E7%BA%A7/) 
```sql
explain select * from A where X=? and Y=?
```
- id select_type table partitions type possible_keys key key_len ref rows filtered Extra
- Extra：
    - using filesort：表示mysql对结果集进行外部排序，不能通过索引顺序达到排序效果。一般有using filesort都建议优化去掉，因为这样的查询cpu资源消耗大。**意味着没有走索引列的排序。**
    - using index：覆盖索引扫描，表示查询在索引树中就可以查找所需数据，不用扫描表数据文件，往往说明性能不错。
    - using temporary：查询有使用临时表，临时数据。一般出现于排序，分组，多表join的情况，查询效率不高，建议优化。
    - using where：sql使用了where过滤，效率较高。
- type：
    - const：通过索引一次命中，匹配一行数据。
    - system：表中只有一行记录，相当于系统表。
    - eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。(索引值不一定是主键，可能回表查询)
    - ref：非唯一性索引，返回匹配某个值的所有。(索引值不一定是主键，可能回表查询)
    - range：范围查询，一般用于between,>,<。(多个索引)
    - index：只遍历索引树。(所有的索引都会遍历。效率极低，因为遍历了索引树)
    - ALL：表示全表扫描，性能最差，几乎不走索引。
    - 执行效率：ALL < index < range < ref < eq_ref < const < system
### 事务的基本特性
- 原子性：一个事物中的操作要么全部成功要么全部失败。**通过undo log 实现(记录了需要回滚的日志信息，事务回滚时撤销已经执行成功的sql)**
- 一致性：事务开始前和结束后，数据库的完整性约束没有被破坏。(实体完整性,参照完整性,用户自定义的完整性)。事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。
- 隔离性：同一时刻只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰，**通过锁机制实现。MVCC**
- 持久性：事务提交后，事务对数据库的所有更新都将保存到数据库中，不能回滚，**通过内存+redo log实现(mysql修改数据同时在内存和redo log记录这次操作，宕机的时候可以从redo log恢复)**
- **原子性是事务隔离的基础，隔离性和持久性是手段，最终目的是为了保持数据的一致性。**
### 事务的隔离级别
- 事务的并发问题：
    - 脏读：事务 A 读取了事务 B 未提交的数据。
    - 不可重复读：事务 A 多次读取同一份数据，事务 B 在此过程中对数据修改并提交，导致事务 A 多次读取同一份数据的结果不一致。
    - 幻读：事务 A 修改数据的同时，事务 B 插入了一条数据，当事务 A 提交后发现还有数据没被修改，产生了幻觉。
    - 不可重复读侧重于 update 操作，幻读侧重于 insert 或 delete。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表。
- 解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表。
- 事务的隔离级别：
    - 读未提交：一个事物可以读取另一个事物未提交的数据。会产生脏读现象。
    - 读已提交：无法对未提交的数据进行读取。会产生不可重复读现象。
    - 可重复读：针对于脏读和不可重复读这些只更新(update)数据的事物可以使用这种隔离级别，但是会产生幻读。幻读是指删除或者插入等修改数据。
    - 串行化读：等一个事物彻底结束后另一个事物才开始进行。能解决上述所有问题，但是性能太低。事物隔离级别越高，性能越低。最高性能是读未提交。
- **事务的隔离级别靠MVCC保证。**
    - 读已提交：每次select都会产生一个ReadView(快照)。
    - 可重复读：只在第一次select的时候产生一个ReadView(快照)，所以解决了可重复读的问题，在这次事务中每次读取到的值都是第一次生成的快照的值。
### MVCC的理解
- InnoDB是一个支持行锁的存储引擎，为了提供更好的并发，使用了非锁定读，不需要等待访问数据上的锁释放，而是读取行的一颗快照，该方法是通过InnoDB MVCC 特性实现的。
- MVCC 是多版本并发控制，作用是让事务在并行发生时，在一定的隔离级别前提下，可以保证某个事务中能实现一致性读，也就是该事务启动时根据某个条件读取到的数据，知道事务结束时，再次执行相同条件，还是读到同一份数据，不会发生变化。
- 可重复读：快照(Read View)在第一次select操作之后创建。
- 读已提交：快照(Read View)在每次select操作之后都会生成最新的，可以读到已经提交的数据。所以会存在不可重复读，幻读的现象。
### 为什么不建议物理删除delete
> Undo log 里记录的都是反向操作
- insert：反向操作是delete，Undo Log里记录的是delete相关信息，存储主键id即可。
- update：反向操作时update，Undo Log里记录的是update前的相关数据。
- delete：反向操作时insert，Undo Log里记录的是insert values(......) 相关的记录。
> 从这里可以知道，更新操作占用undo空间的大小排序：delete > update > insert
- 所以不建议物理删除数据，会产生大量的Undo Log，Undo Log快被写满就会发生切换，在此期间会有大量的IO操作，导致业务的DML都会变的很慢。
### 怎么处理慢查询
- 首先分析语句是否加载了其余没用的列，进行sql的重写。
- 分析语句的执行计划，获得其使用索引的情况，之后修改语句或者索引，使得语句尽可能的命中索引。
- 如果对语句的优化已经无法进行，可以考虑表中的数据量是否太大，如果是的话可以进行横向和纵向的分库分表。
### MySQL主从同步原理
- master主机(binlog dump thread) slave(I/O thread SQL thread)
- 主库记录数据的所有变更到binlog 日志中。当binlog日志有变动时，log dump线程就会读取其内容并发送给从节点。
- 从节点I/O线程接受bin log内容，并将其写入relay log 文件中。
- 从节点的SQL线程读取relay log 文件内容在从库中执行，保证主从数据库的一致性。(MySQL默认复制方式是异步的：增量同步)
- 全同步复制(等待所有从库完成同步日志操作) 半同步复制(等待一定数量的从库完成同步日志操作)
### 简述MyISAM和InnoDB的区别
- MyISAM：
  - 不支持事务，但是每次查询都是原子的。
  - 支持表级锁，每次操作都是对整个表加锁。
  - 存储表的总行数。
  - 一个MyISAM表有三个文件，索引文件，表结构文件，数据文件。
  - 采用非聚簇索引，索引文件的数据域存储指向数据文件的指针。辅助索引与主键索引基本一致，但是辅助索引不用保证唯一性。
- InnoDB：
  - 支持ACID事务，支持事务的4种隔离级别。
  - 支持行级锁及外键约束，因此可以支持写并发。
  - 不存储总行数。
  - 数据和索引在同一个文件中。
### MySQL 普通索引和唯一索引的区别
- **这两类索引在查询能力上是没差别的，主要考虑的是对更新性能的影响。建议尽量选择普通索引。**
- 普通索引：查找到第一个满足条件的记录后，继续向后遍历，直到第一个不满足条件的记录。
- 唯一索引：由于索引定义了唯一性，查找到第一个满足条件的记录后，直接停止继续检索。
### 索引失效条件
- 条件是or，如果还想让or条件生效，给or每个字段加个索引
- like开头% eg: where name like '%风'
- 如果列类型是字符串，那一定要在条件中将数据使用引号引用起来，否则不会使用索引
- where中索引列使用了**函数或有运算**
- 模糊查询时like '%风' 用不到索引  like '风%' 能用到索引

