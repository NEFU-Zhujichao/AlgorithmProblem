# MySQL面经
[MySQL](https://www.zhihu.com/people/aobingJava/posts?page=2) 
SELECT * FROM table LIMIT 5,10; //检索记录行6-15
### [深入理解 MySQL事务](https://blog.csdn.net/qq_35246620/article/details/61200815?utm_source=app&app_version=4.5.8)
### 什么是索引
官方介绍索引是帮助MySQL高效获取数据的数据结构。更通俗的说，数据库索引好比是一本书前面的目录，能加快数据库的查询速度。  
一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往是存储在磁盘上的文件中的（可能存储在单独的索引文件中，也可能和数据一起存储在数据文件中）。  
我们通常所说的索引，包括聚簇索引、覆盖索引、组合索引、前缀索引、唯一索引等，没有特别说明，默认都是使用B+树结构组织（多路搜索树，并不一定是二叉的）的索引。  
MySQL选用B+树这种数据结构作为索引，可以提高查询索引时的磁盘IO效率，并且可以提高范围查询的效率，并且B+树里的元素也是有序的。  
### 索引的优势和劣势
优势： 
- 可以提高数据检索的效率，降低数据库的IO成本，类似于书的目录。
- 通过索引列对数据进行排序，降低数据排序的成本，降低了CPU的消耗。
  - 被索引的列会自动进行排序，包括【单列索引】和【组合索引】，只是组合索引的排序要复杂一些。
  - 如果按照索引列的顺序进行排序，对应order by语句来说，效率就会提高很多。

劣势：
- 索引会占据磁盘空间
- 索引虽然会提高查询效率，但是会降低更新表的效率。比如每次对表进行增删改操作，MySQL不仅要保存数据，还要保存或者更新对应的索引文件。
### 索引类型
> 主键索引  

索引列中的值必须是唯一的，不允许有空值。
> 普通索引

MySQL中基本索引类型，没有什么限制，允许在定义索引的列中插入重复值和空值。
> 唯一索引

索引列中的值必须是唯一的，但是允许为空值。
> 全文索引

只能在文本类型CHAR,VARCHAR,TEXT类型字段上创建全文索引。字段长度比较大时，如果创建普通索引，在进行like模糊查询时效率比较低，这时可以创建全文索引。MyISAM和InnoDB中都可以使用全文索引。一般不用，因为有更好的搜索引擎，ES。
> 空间索引

MySQL在5.7之后的版本支持了空间索引，而且支持OpenGIS几何数据模型。MySQL在空间索引这方面遵循OpenGIS几何数据模型规则。
> 前缀索引

在文本类型如CHAR,VARCHAR,TEXT类列上创建索引时，可以指定索引列的长度，但是数值类型不能指定。
> 其他（按照索引列数量分类）
1. 单列索引
2. 组合索引  
组合索引的使用，需要遵循最左前缀匹配原则（最左匹配原则）。一般情况下在条件允许的情况下使用组合索引替代多个单列索引使用。
### 索引的数据结构
> Hash表

Hash表，在Java中的HashMap，TreeMap就是Hash表结构，以键值对的方式存储数据。我们使用Hash表存储表数据Key可以存储索引列，Value可以存储行记录或者行磁盘地址。**Hash表在等值查询时效率很高，时间复杂度为O(1)；但是不支持范围快速查找，范围查找时还是只能通过扫描全表方式。**  
**显然这种并不适合作为经常需要查找和范围查找的数据库索引使用。**

### 要创建出好的索引要顾及到很多的方面
- 最左前缀匹配原则。这是非常重要、非常重要、非常重要（重要的事情说三遍）的原则，MySQL会一直向右匹配直到遇到范围查询 （>,<,BETWEEN,LIKE）就停止匹配。
- 尽量选择区分度高的列作为索引，区分度的公式是 COUNT(DISTINCT col)/COUNT(*)。表示字段不重复的比率，比率越大我们扫描的记录数就越少。
- 索引列不能参与计算，尽量保持列“干净”。比如， FROM_UNIXTIME(create_time)='2016-06-06' 就不能使用索引，原因很简单，B+树中存储的都是数据表中的字段值，但是进行检索时，需要把所有元素都应用函数才能比较，显然这样的代价太大。所以语句要写成 ：create_time=UNIX_TIMESTAMP('2016-06-06')。
- 尽可能的扩展索引，不要新建立索引。比如表中已经有了a的索引，现在要加（a,b）的索引，那么只需要修改原来的索引即可。
- 单个多列组合索引和多个单列索引的检索查询效果不同。在MySQL5.0以后的版本中，有“合并索引”的策略，翻看了《高性能MySQL 第三版》，书作者认为：还是应该建立起比较好的索引，而不应该依赖于“合并索引”这么一个策略。
- “合并索引”策略简单来讲，就是使用多个单列索引，然后将这些结果用“union或者and”来合并起来。
### MySQL执行计划怎么看？
[click](https://nyimac.gitee.io/2020/08/16/MySQL%E9%AB%98%E7%BA%A7/) 
```sql
explain select * from A where X=? and Y=?
```
> **id select_type table partitions type possible_keys key key_len ref rows filtered Extra**
- Extra：
    - using filesort：表示mysql对结果集进行外部排序，不能通过索引顺序达到排序效果。一般有using filesort都建议优化去掉，因为这样的查询cpu资源消耗大。**意味着没有走索引列的排序。**
    - using index：覆盖索引扫描，表示查询在索引树中就可以查找所需数据，不用扫描表数据文件不用回表查询，往往说明性能不错。
    - using temporary：查询有使用临时表，临时数据。一般出现于排序，分组，多表join的情况，查询效率不高，建议优化。
    - using where：sql使用了where过滤，效率较高。
- type：
    - const：通过索引一次命中，匹配一行数据。
    - system：表中只有一行记录，相当于系统表。
    - eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。(索引值不一定是主键，可能回表查询)
    - ref：非唯一性索引，返回匹配某个值的所有。(索引值不一定是主键，可能回表查询)
    - range：范围查询，一般用于between,>,<。(多个索引)
    - index：只遍历索引树。(所有的索引都会遍历。效率极低，因为遍历了索引树)
    - ALL：表示全表扫描，性能最差，几乎不走索引。
    - 执行效率：ALL < index < range < ref < eq_ref < const < system
### 事务的基本特性
- 原子性：一个事物中的操作要么全部成功要么全部失败。**通过undo log 实现(记录了需要回滚的日志信息，事务回滚时撤销已经执行成功的sql)**
- 一致性：事务开始前和结束后，数据库的完整性约束没有被破坏。(实体完整性,参照完整性,用户自定义的完整性)。事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。
- 隔离性：同一时刻只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰，**通过锁机制实现。MVCC**
- 持久性：事务提交后，事务对数据库的所有更新都将保存到数据库中，不能回滚，**通过内存+redo log实现(mysql修改数据同时在内存和redo log记录这次操作，宕机的时候可以从redo log恢复)**
- **原子性是事务隔离的基础，隔离性和持久性是手段，最终目的是为了保持数据的一致性。**
### 事务的隔离级别
> 事务的并发问题：
- 脏读：事务 A 读取了事务 B 未提交的数据。
- 不可重复读：事务 A 多次读取同一份数据，事务 B 在此过程中对数据修改并提交，导致事务 A 多次读取同一份数据的结果不一致。
- 幻读：事务 A 修改数据的同时，事务 B 插入了一条数据，当事务 A 提交后发现还有数据没被修改，产生了幻觉。
- 不可重复读侧重于 update 操作，幻读侧重于 insert 或 delete。
- Innodb解决幻读通过 行锁 + 间隙锁 来解决。
> 事务的隔离级别：
- 读未提交：一个事物可以读取另一个事物未提交的数据。会产生脏读现象。
- 读已提交：无法对未提交的数据进行读取。会产生不可重复读现象。
- 可重复读：针对于脏读和不可重复读这些只更新(update)数据的事物可以使用这种隔离级别，但是会产生幻读。幻读是指删除或者插入等修改数据。
- 串行化读：等一个事物彻底结束后另一个事物才开始进行。能解决上述所有问题，但是性能太低。事物隔离级别越高，性能越低。
> **事务的两种隔离级别靠MVCC保证。**
- 读已提交：每次select都会产生一个ReadView(快照)。
- 可重复读：只在第一次select的时候产生一个ReadView(快照)，所以解决了不可重复读的问题，在这次事务中每次读取到的值都是第一次生成的快照的值。
### MVCC的理解
- InnoDB是一个支持行锁的存储引擎，为了提供更好的并发，使用了非锁定读，不需要等待访问数据上的锁释放，而是读取行的一个快照，该方法是通过InnoDB MVCC 特性实现的。
- MVCC 是多版本并发控制，作用是让事务在并行发生时，在一定的隔离级别前提下，可以保证某个事务中能实现一致性读，也就是该事务启动时根据某个条件读取到的数据，直到事务结束时，再次执行相同条件，还是读到同一份数据，不会发生变化。
- 可重复读：快照(Read View)在第一次select操作之后创建。
- 读已提交：快照(Read View)在每次select操作之后都会生成最新的，可以读到已经提交的数据。所以会存在不可重复读，幻读的现象。
### 为什么不建议物理删除delete
> Undo log 里记录的都是反向操作
- insert：反向操作是delete，Undo Log里记录的是delete相关信息，存储主键id即可。
- update：反向操作是update，Undo Log里记录的是update前的相关数据。
- delete：反向操作是insert，Undo Log里记录的是insert into table(......) values(......) 相关的记录。
> 从这里可以知道，更新操作占用undo空间的大小排序：delete > update > insert
- 所以不建议物理删除数据，会产生大量的Undo Log，Undo Log快被写满就会发生切换，在此期间会有大量的IO操作，导致业务的DML都会变的很慢。
### 怎么处理慢查询
- 首先分析语句是否加载了其余没用地列，进行sql的重写。
- 分析语句的执行计划，获得其使用索引的情况，之后修改语句或者索引，使得语句尽可能的命中索引。
- 如果对语句的优化已经无法进行，可以考虑表中的数据量是否太大，如果是的话可以进行横向和纵向的分库分表。
### 简述MyISAM和InnoDB的区别
- MyISAM：
  - 不支持事务，但是每次查询都是原子的。
  - 支持表级锁，每次操作都是对整个表加锁。
  - 存储表的总行数。
  - 一个MyISAM表有三个文件，索引文件，表结构文件，数据文件。
  - 采用非聚簇索引，主键索引B+树的叶子节点的数据域存储指向数据文件的指针。辅助索引与主键索引基本一致，但是辅助索引不用保证唯一性。
- InnoDB：
  - 支持事务，支持事务的4种隔离级别。
  - 支持行级锁及外键约束，因此可以支持写并发。
  - 不存储总行数。
  - 数据和索引在同一个文件中，还有一个表结构文件。
  - 采用聚簇索引，主键索引B+树的叶子节点的数据域存储数据的行记录。辅助索引B+树的叶子节点的数据域存储行记录的主键值和索引值，需要回表查询具体数据，除非是覆盖索引。
### MySQL 普通索引和唯一索引的区别
[普通索引和唯一索引如何选择](https://www.cnblogs.com/seaspring/p/12928124.html) 
> **这两类索引在查询能力上是没差别的，主要考虑的是对更新性能的影响。建议尽量选择普通索引。**

查询性能比较：     
- 普通索引：查找到第一个满足条件的记录后，继续向后遍历，直到第一个不满足条件的记录。
- 唯一索引：由于索引定义了唯一性，查找到第一个满足条件的记录后，直接停止继续检索。

更新性能比较：  
更新操作的时候，数据如果不在内存中，且不影响数据（比如不影响数据的唯一性的情况下），我们把更新操作纪录到 change buffer 上，并不需要从磁盘上读取数据页。这时候，如果来了一个查询动作，刚好要查这条数据的情况下，MySQL 会从磁盘上读取这个数据页，然后发现 change buffer 有修改了这个数据页，会将这个数据页修改的内容 merge 到这个数据页上。    
那在更新数据的时候，数据库是如何操作的，总体来说分两种情况，要操作的数据所在的数据页在内存中和不在内存中。   
**数据页在内存中**：  
- 如果是普通索引，则直接更新内存中的数据。（这里简化了很多还涉及到 redolog 和 binlog 等）
- 如果是唯一索引，碰巧要做的是插入操作，则需要将需要插入的字段值和数据页中的比较看是否存在，决定是否可以插入。 两种操作的耗时差别很小。

**数据页不在内存中**：    
- 如果是普通索引，则在 change buffer 中记录对那个数据页做了什么样的修改。
- 如果是唯一索引，则需要将数据页读取到内存中，判断是否满足唯一性约束，数据已经读入内存了，这时候肯定不会再使用 change buffer 了，因为已经多了一次 IO 的随机读了。  
所以从更新角度看，普通索引可以利用 change buffer 更新操作的性能比唯一索引要更好。 这里面要说明的是有些人可能会认为像插入操作，我们需要一个主键，主键是唯一索引，所以插入操作是用不到 change buffer，这样是不对的，因为一个表一般除了主键还有二级索引，主键用不到，二级索引可以用到 change buffer。  
> Change buffer 适用场景
- 如果我们的数据是读少，写多的，比如日志数据。
- 还有就是我们系统中的历史库，几乎不会再读取数据了，却需要随时搬迁历史数据到此库中，肯定没有唯一冲突了，可以考虑把唯一索引改成普通索引，以提升搬迁性能。
> Change buffer 不适用场景
- 如果一个数据在写入后，经常需要立刻读出来，那么我们并不能降低随机读，而且还会增加 change buffer 的操作负担，所以并不适合。
- 如果数据库的数据都只有主键，或只有唯一索引，也不合适。
### MySQL性能优化：什么是索引下推？
不使用索引条件下推优化时存储引擎通过索引检索到数据，然后返回给MySQL服务器，然后服务器判断数据是否符合条件。  
当使用索引条件下推优化时，如果存在某些**被索引的列的判断条件时**，MySQL服务器将这一部分判断条件传递给存储引擎，然后**由存储引擎通过判断索引是否符合MySQL服务器传递的条件**，只有当索引符合条件时才会将数据检索出来返回给MySQL服务器。索引条件下推优化可以减少存储引擎查询基础表的次数，也可以减少MySQL服务器从存储引擎接收数据的次数。
```sql
SELECT * from user where  name like '陈%' and age=20
```
![](https://pic3.zhimg.com/80/v2-04b4a496ab53eccc5feba150bf9fb7ea_720w.jpg)  
- 没有索引下推时会忽略age这个字段，直接通过name进行查询，在(name,age)这课树上查找到了两个结果，id分别为2,1，然后拿着取到的id值一次次的回表查询，因此这个过程需要回表两次。
![](https://pic1.zhimg.com/80/v2-211aaba883221c81d5d7578783a80764_720w.jpg)  
- 存在索引下推时InnoDB并没有忽略age这个字段，而是在索引内部就判断了age是否等于20，对于不等于20的记录直接跳过，因此在(name,age)这棵索引树中只匹配到了一个记录，此时拿着这个id去主键索引树中回表查询全部数据，这个过程只需要回表一次。
### 哪些字段适合建立索引
1. 表的主键、外键必须有索引
2. 经常与其他表进行连接的表，在连接字段上应该建立索引 join
3. 经常出现在Where子句中的字段，特别是大表的字段，应该建立索引
4. 索引应该建在选择性高的字段上
5. 索引应该建在小字段上，对于大的文本字段甚至超长字段，不要建索引
6. 查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度 order by
7. 查询中统计或者分组字段 group by
8. 单键/组合索引的选择问题，组合索引性价比更高
### 索引失效条件
- 没有遵循最左前缀匹配原则
- 范围查询后的条件用不到，或者是使用范围查询后，如果范围内的记录过多，会导致索引失效，因为从自定义索引映射到主键索引需要耗费太多的时间，反而不如全表扫描来得快
- 在使用不等于(!= 或者<>)时，有时会无法使用索引会导致全表扫描
- 在使用IS NULL或者IS NOT NULL时可能会导致索引失效，但是如果允许字段为空，则
  - IS NULL 不会导致索引失效
  - IS NOT NULL 会导致索引失效
- 如果使用or，可能导致索引失效。所以要减少or的使用，可以使用 union all 或者 union 来替代。条件是or，如果还想让or条件生效，给or每个字段加个索引
- 如果列类型是字符串，那一定要在条件中将数据使用单引号引用起来，否则不会使用索引
- where中索引列使用了**函数或有运算**
- 模糊查询时like '%风' 用不到索引 like '风%' 能用到索引。但是有时必须使用其他类型的模糊查询，这时就需要用覆盖索引来解决索引失效的问题。只遍历索引树也比遍历全表要好一点。
### SQL 调优
SQL 调优往往是解决数据库问题的第一步，往往投入少部分精力就能获得较大的收益。SQL 调优主要目的是尽可能的让那些慢 SQL 变快，手段其实也很简单就是让 SQL 执行尽量命中索引。  
**开启慢 SQL 记录**  
如果你使用的是 MySQL，需要在 MySQL 配置文件中配置几个参数即可。
```text
slow_query_log=on
long_query_time=1
slow_query_log_file=/path/to/log
```
**调优的工具**  
常常会用到 explain 这个命令来查看 SQL 语句的执行计划，通过观察执行结果很容易就知道该 SQL 语句是不是全表扫描、有没有命中索引。  
**架构优化**  
当单台数据库实例扛不住，我们可以增加实例组成集群对外服务。  
当发现读请求明显多于写请求时，我们可以让主实例负责写，从实例对外提供读的能力。  
如果读实例压力依然很大，可以在数据库前面加入缓存如 redis，让请求优先从缓存取数据减少数据库访问。  
缓存分担了部分压力后，数据库依然是瓶颈，这个时候就可以考虑分库分表的方案了。  
### MySQL分库分表
> 水平切分

水平切分又称为 Sharding，它是将同一个表中的记录拆分到多个结构相同的表中。当一个表的数据不断增多时，Sharding 是必然的选择，它可以将数据分布到集群的不同节点上，从而缓解单个数据库的压力。  
![](https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1FpwqHyYbEIPyeesNicgZ2s5NTDY4S3c0lral4cRic5FGqO5U5RicuhKx7VqPgk75CC6Ra9Vhc7PCdM12w/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)
> 垂直切分

垂直切分是将一张表按列分成多个表，通常是按照列的关系密集程度进行切分，也可以利用垂直切分将经常被使用的列和不经常被使用的列切分到不同的表中。  
在数据库的层面使用垂直切分将按数据库中表的密集程度部署到不同的库中，例如将原来电商数据部署库垂直切分称商品数据库、用户数据库等。  
![](https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1FpwqHyYbEIPyeesNicgZ2s5NTjeVApdic37kA3icLTWwFHHj33WLFiaFBTlqxqPvBpZ8icUWv0f3FWJh27w/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)
> Sharding 策略
- 哈希取模：hash(key)%N
- 范围：可以是 ID 范围也可以是时间范围
- 映射表：使用单独的一个数据库来存储映射关系
> Sharding存在的问题
- 事务问题：使用分布式事务来解决
- 连接：可以将原来地连接分解成多个单表查询，然后在用户程序中进行连接。
- 唯一性
  - 使用全局唯一 ID （GUID）
  - 为每个分片指定一个 ID 范围
  - 分布式 ID 生成器（如 Twitter 的 Snowflake 算法）
### MySQL主从复制原理
> master主机 (binlog thread) slave (I/O thread SQL thread)
- 主库记录数据的所有变更到二进制日志(binlog)中。当binlog日志有变动时，binlog线程就会读取其内容并发送给从节点。
- 从节点I/O线程接受binlog内容，并将其写入中继日志(relay log)文件中。
- 从节点的SQL线程读取relay log 文件内容在从库中执行，保证主从数据库的一致性。(MySQL默认复制方式是异步的：增量同步)
- 全同步复制(等待所有从库完成同步日志操作) 半同步复制(等待一定数量的从库完成同步日志操作)
### MySQL读写分离
主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。  
读写分离能提高性能的原因在于：
- 主从服务器负责各自的读和写，极大程度缓解了锁的争用。
- 从服务器可以使用 MyISAM，提升查询性能以及节约系统开销。
- 增加冗余，提高可用性。 

读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。  
![](https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1FpwqHyYbEIPyeesNicgZ2s5NTdSFSNCGjGtjJX0m6iaKL1t7TliaOVnBggj0PJ8cNOPwN2lXJhqDQN8ng/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)
