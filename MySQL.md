# MySQL面经
### MySQL执行计划怎么看？
```sql
explain select * from A where X=? and Y=?
```
- id select _type table partitions type possible_keys key key_len ref rows filtered Extra
- Extra：
    - using filesort：表示mysql对结果集进行外部排序，不能通过索引顺序达到排序效果。一般有using filesort都建议优化去掉，因为这样的查询cpu资源消耗大。**意味着没有走索引列的排序。**
    - using index：覆盖索引扫描，表示查询在索引树中就可以查找所需数据，不用扫描表数据文件，往往说明性能不错。
    - using temporary：查询有使用临时表，临时数据。一般出现于排序，分组，多表join的情况，查询效率不高，建议优化。
    - using where：sql使用了where过滤，效率较高。
- type：
    - const：通过索引一次命中，匹配一行数据。
    - system：表中只有一行记录，相当于系统表。
    - eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。(索引值不一定是主键，可能回表查询)
    - ref：非唯一性索引，返回匹配某个值的所有。(索引值不一定是主键，可能回表查询)
    - range：范围查询，一般用于between,>,<。(多个索引)
    - index：只遍历索引树。(所有的索引都会遍历。效率极低，因为遍历了索引树)
    - ALL：表示全表扫描，性能最差，几乎不走索引。
    - 执行效率：ALL < index < range < ref < eq_ref < const < system
### 事务的基本特性
- 原子性：一个事物中的操作要么全部成功要么全部失败。**通过undo log 实现**
- 一致性：事务开始前和结束后，数据库的完整性约束没有被破坏。(实体完整性,参照完整性,用户子定义的完整性)
- 隔离性：同一时刻只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰，**通过锁机制实现。MVCC**
- 持久性：事务提交后，事务对数据库的所有更新都将保存到数据库中，不能回滚，**通过redo log实现。**
- **原子性是事务隔离的基础，隔离性和持久性是手段，最终目的是为了保持数据的一致性。**
### 事务的隔离级别
- 事务的并发问题：
    - 脏读：事务 A 读取了事务 B 未提交的数据。
    - 不可重复读：事务 A 多次读取同一份数据，事务 B 在此过程中对数据修改并提交，导致事务 A 多次读取同一份数据的结果不一致。
    - 幻读：事务 A 修改数据的同时，事务 B 插入了一条数据，当事务 A 提交后发现还有数据没被修改，产生了幻觉。
    - 不可重复读侧重于 update 操作，幻读侧重于 insert 或 delete。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表。
- 事务的隔离级别：
    - 读未提交：一个事物可以读取另一个事物未提交的数据。会产生脏读现象。
    - 读已提交：无法对未提交的数据进行读取。会产生不可重复读现象。
    - 可重复读：针对于脏读和不可重复读这些只更新(update)数据的事物可以使用这种隔离级别，但是会产生幻读。幻读是指删除或者插入等修改数据。
    - 串行化读：等一个事物彻底结束后另一个事物才开始进行。能解决上述所有问题，但是性能太低。事物隔离级别越高，性能越低。最高性能是读未提交。
- **事务的隔离级别靠MVCC保证。**
    - 读已提交：每次select都会产生一个ReadView(快照)。
    - 可重复读：只在第一次select的时候产生一个ReadView(快照)，所以解决了可重复读的问题，在这次事务中每次读取到的值都是第一次生成的快照的值。
### 怎么处理慢查询
- 首先分析语句是否加载了其余没用的列，进行sql的重写。
- 分析语句的执行计划，获得其使用索引的情况，之后修改语句或者索引，使得语句尽可能的命中索引。
- 如果对语句的优化已经无法进行，可以考虑表中的数据量是否太大，如果是的话可以进行横向和纵向的分库分表。
### 