# 计算机网络与操作系统面经
1. [字节后端面经有很多计网和操作系统](https://www.nowcoder.com/discuss/619628) 
2. [大佬总结](https://blog.csdn.net/xiaoming100001/article/details/81109617)
### 运输层总结
- 运输层的一个很重要的功能就是复用和分用。应用层不同进程的报文通过不同的端口向下交到运输层，再往下就共用网络层提供的服务。
- TCP传送的数据单位协议是**TCP报文段。**UDP传送的数据单位协议是**UDP报文或用户数据报。**
### TCP/UDP区别
> UDP：对网络通讯质量要求不高时，要求网络通讯速度要快的场景
  - 无连接，发送数据之前不需要建立连接。
  - 尽最大努力交付，不保证可靠交付，不使用拥塞控制。
  - 面向报文，适合多媒体通信。
  - 支持一对一，一对多，多对一，多对多的交互通信。
  - 首部开销小，8个字节。
> TCP：当对网络通讯质量有要求时，比如HTTP、HTTPS、FTP等传输文件的协议， POP、SMTP等邮件传输的协议
  - 面向连接。
  - 每一条TCP有且只有两个端点，为一对一关系。
  - 提供可靠交付。
  - 全双工通信，全双工为即可传输又可接收。
  - 面向字节流。
### TCP为什么可靠
[TCP为什么可靠](https://zhuanlan.zhihu.com/p/130730913)
- 乱序重排
- 应答确认
- 报文重传
- 流量控制
### TCP拥塞控制
- 
### https与http区别
- HTTPS是身披SSL外壳的HTTP。HTTPS是一种通过计算机网络进行安全通信的传输协议，经由HTTP进行通信，利用SSL/TLS建立全信道，加密数据包。HTTPS使用的主要目的是提供对网站服务器的身份认证，同时保护交换数据的隐私与完整性。
#### HTTPS有如下特点：
### 步骤
1. 用户在浏览器发起HTTPS请求（如 https://www.mogu.com/），默认使用服务端的443端口进行连接；
2. HTTPS需要使用一套CA数字证书，证书内会附带一个公钥Pub，而与之对应的私钥Private保留在服务端不公开；
3. 服务端收到请求，返回配置好的包含公钥Pub的证书给客户端；
4. 客户端收到证书，校验合法性，主要包括是否在有效期内、证书的域名与请求的域名是否匹配，上一级证书是否有效（递归判断，直到判断到系统内置或浏览器配置好的根证书），如果不通过，则显示HTTPS警告信息，如果通过则继续；
5. 客户端生成一个用于对称加密的随机Key，并用证书内的公钥Pub进行加密，发送给服务端；
6. 服务端收到随机Key的密文，使用与公钥Pub配对的私钥Private进行解密，得到客户端真正想发送的随机Key；
7. 服务端使用客户端发送过来的随机Key对要传输的HTTP数据进行对称加密，将密文返回客户端；
8. 客户端使用随机Key对称解密密文，得到HTTP数据明文；
9. 后续HTTPS请求使用之前交换好的随机Key进行对称加解密。
- 内容加密：采用混合加密技术，中间者无法直接查看明文内容
- 验证身份：通过证书认证客户端访问的是自己的服务器
- 保护数据完整性：防止传输的内容被中间人冒充或者篡改
> - **混合加密**：结合非对称加密和对称加密技术。客户端使用对称加密生成密钥对传输数据进行加密，然后使用非对称加密的公钥再对秘钥进行加密，所以网络上传输的数据是被秘钥加密的密文和用公钥加密后的秘密秘钥，因此即使被黑客截取，由于没有私钥，无法获取到加密明文的秘钥，便无法获取到明文数据。
> - **数字摘要**：通过单向hash函数对原文进行哈希，将需加密的明文“摘要”成一串固定长度(如128bit)的密文，不同的明文摘要成的密文其结果总是不相同，同样的明文其摘要必定一致，并且即使知道了摘要也不能反推出明文。
> - **数字签名技术**：数字签名建立在公钥加密体制基础上，是公钥加密技术的另一类应用。它把公钥加密技术和数字摘要结合起来，形成了实用的数字签名技术。
- 收方能够证实发送方的真实身份；
- 发送方事后不能否认所发送过的报文；
- 收方或非法者不能伪造、篡改报文。
- **非对称加密过程需要用到公钥进行加密，那么公钥从何而来？其实公钥就被包含在数字证书中，数字证书通常来说是由受信任的数字证书颁发机构CA，在验证服务器身份后颁发，证书中包含了一个密钥对（公钥和私钥）和所有者识别信息。数字证书被放到服务端，具有服务器身份验证和数据传输加密功能。**
### TCP(传输控制协议)3次握手，为什么不能是2次握手？4次握手？
- 三次握手。
- 为什么不是2次？
    - 主要是为了防止已失效的请求连接报文忽然又传送到了，从而产生错误。假定A向B发送一个连接请求，由于一些原因，导致A发出的连接请求在一个网络节点逗留了比较多的时间。此时A会将此连接请求作为无效处理。又重新向B发起了一次新的连接请求，B正常收到此连接请求后建立了连接，数据传输完成后释放了连接。**如果此时A发出的第一次请求又到达了B，B会以为A又发起了一次连接请求，如果是两次握手，此时连接就建立了，B会一直等待A发送数据，从而白白浪费B的资源。** 如果是三次握手：由于A没有发起连接请求，也就不会理会B的连接响应，B没有收到A的确认连接，就会关闭掉本次连接。
    - 同时也不能保证传输的可靠性。
- 为什么不是4次？
    - 理论上讲不论握手多少次都不能确认一条信道是“可靠”的，但通过3次握手可以至少确认它是“可用”的，再往上加握手次数不过是提高“它是可用的”这个结论的可信程度。
    - 避免资源浪费。
- 三次握手本质：
    - 本质：1、保证信道数据传输的可靠性；2、避免资源浪费 3、三次是保证双方互相明确对方能收能发的最低值。
    - TCP 的可靠连接是靠 seq（ sequence numbers 序列号）来达成的。
### TCP4次挥手，为什么等2MLS？ Maximum Segment Lifetime 报文最大生存时间
- 四次挥手。
1. 为了保证 A 发送的最后一个 ACK 报文段能够到达 B。
2. 防止 “已失效的连接请求报文段”出现在本连接中。A 在发送完最后一个 ACK 报文段后，再经过时间 2MSL，就可以使本连接持续的时间内所产生的所有报文段，都从网络中消失。这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。
### get post 区别
- get用于请求服务器返回资源，post一般用于表单的提交。
- get方法请求参数会拼接在URL上不安全。post方法请求参数放在**请求体body中。**
- get请求URL有长度限制，post对长度无要求。
- get请求会被浏览器主动cache，post不会，除非手动设置。
- get请求在浏览器反复的 回退/前进 操作是无害的，而post操作会再次提交表单请求。
- **get请求在发送过程中会产生一个TCP数据包，post在发送过程中会产生两个TCP数据包。** 对于get请求，浏览器会把http header和data一并发送出去，服务器响应200；而对于post，浏览器先发送header，服务器响应100 continue,浏览器再发送data，服务器响应200 ok。
### cookie和session区别
- Cookie存放在客户端浏览器中   Session存放在服务器中。
- cookie的大小受限制，单个cookie保存的数据**不能超过4K**，很多浏览器都限制一个站点**最多保存20个cookie。**  session的大小一般不受限制。
- 工作原理：
    - 客户端将cookie把数据存在在浏览器中，这样浏览器再次请求的时候就会带上这个cookie，浏览器就认识这个请求了。客户端第一次访问服务器的时候浏览器会在响应头中加上Set-Cookie信息，当再次发送一个请求的时候，请求会在请求头上带上Cookie:xxx,也就是前面自己的数据，目的是让服务器认识自己。
    - 服务器为每一次会话创建了一块内存区域来存在数据，第一次请求服务器把数据存放在了服务器中，服务器给客户端响应一个编号，下次再来请求的时候拿着这个编号在服务器的内存空间中可以找到自己的数据。 客户端浏览器第一次请求服务器，服务器会创建cookie对象并且把数据按照key-value的形式起来，然后在响应头中加上Set-Cookie:xxx（这里的xxx其实就是sessionId）,下一次访问的时候，会在请求头中加上Cookie:xxx（实际上session是基于cookie实现的）
### 键入网址后，期间发生了什么
> 1. 浏览器做的第一步工作是解析 URL
- 对 URL 进行解析之后，浏览器确定了 Web 服务器和文件名，接下来就是根据这些信息来生成 HTTP 请求消息了。
> 2. 域名对应的真实地址查询 —— DNS服务器
- 客户端首先会发出一个 DNS 请求，问 www.server.com 的 IP 是啥，并发给本地 DNS 服务器。本地域名服务器收到客户端的请求后，如果缓存里的表格能找到 www.server.com，则它直接返回 IP 地址。如果没有，本地 DNS 会去请求它的根域名服务器。根域名服务器返回顶级域名服务器地址，向顶级域名服务器发送请求之后，顶级域名服务器会返回权威 DNS 服务器。权威 DNS 服务器查询后将对应的 IP 地址 X.X.X.X 告诉本地 DNS。
> 3. 通过协议栈中的各种协议完成数据包的填充。(TCP、UDP、IP、ICMP、ARP)
> 4. TCP三次握手    三次握手目的是保证双方都有发送和接收的能力。
> 5. 连接建立后，浏览器会通过该连接向远程服务器发送HTTP的GET请求。远程服务器找到资源并使用HTTP响应返回该资源，值为200的HTTP响应状态码表示一个正确的响应。
> 6. 此时Web服务器提供资源服务，客户端开始下载资源。浏览器解析资源去渲染页面。
> 7. 最后，客户端要离开了，向服务器发起了 TCP 四次挥手，至此双方的连接就断开了。