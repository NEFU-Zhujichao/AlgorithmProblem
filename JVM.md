# JVM面经
### JVM包括两种数据类型
- 反射，就是在运行时获取某个类的类型相关信息，如它的字段信息，方法信息，构造函数信息，父类信息，实现的接口信息。
- 基本类型：数值类型，boolean类型，和returnAddress类型
  - 数值类型包括，整型，浮点型，和char类型。boolean类型同样只有true和false。returnAddress类型是一个指针，指向jvm指令的操作码，在Java中没有与之对应的类型。
- 引用类型：类类型，数组类型，和接口类型。
### JVM内存模型
JVM调优在堆中调
> 运行时公有数据区
- 方法区：static、final、Class类模板、常量池
- 栈：8大基本类型、对象引用、实例方法
> 运行时私有数据区
- pc寄存器：jvm支持一次运行多个线程，每个线程都有自己的pc寄存器，任何时候一个线程只能运行一个方法的代码。
- jvm栈：每一个jvm线程都有一个私有的jvm栈，随着线程的创建而创建，栈中存储的是帧。
- native方法栈：native方法不是用Java语言写的，为了支持它需要使用传统栈，如C语言栈。不过jvm不能加载native方法，所以也不需要提供native方法需要的栈。
**一个JVM只有一个堆内存。** 
- 堆Heap(HotSpot)：类、方法、常量、变量、保存我们所有引用类型的真实对象。
    - 堆分为三个区域：新生代、老年代、元空间。
    - 永久区：这个区域是常驻内存的。用来存放jdk自身携带的Class对象，interface元数据。存储的是java运行时的环境和类信息。这个区域不存在垃圾回收。关闭VM就会释放这个区域的内存。
      - jdk 1.6之前：永久代、常量池是在方法区
      - jdk1.7：永久代，但是慢慢的退化了，去永久代。常量池在堆中。方法区在堆中。
      - jdk1.8之后：无永久代，常量池在元空间中。
    - 元空间：逻辑上存在，物理上不存在。
### GC
- 初始堆内存大小为10M：默认1/64 最大堆内存大小为10M：默认1/4 
- -Xms10m -Xmx10m -Xlog:gc*           
> GC回收在伊甸园区和老年代。新生代分为伊甸园区、幸存区from、幸存区to。
**复制算法最佳使用场景：对象存活度较低。也就是新生代，所以新生代使用复制算法。**
> 年轻代主要用复制算法 from -> to 谁空谁是to区。老年代使用标记清除 + 标记压缩混合。
- 复制算法：在Eden区存活的对象存入To区，From区的对象也移动到To区，然后To区变为From区，From区变为To区。
    - 优点：没有内存碎片。
    - 缺点：浪费了内存空间。因为浪费了幸存区的to区，它一直是空着的。极端情况从from到to移动一大堆对象，就会移动的时间很长，浪费资源。
- 标记清除算法：第一次扫描，将还在使用的对象进行标记，第二次扫描，对没有标记的对象进行清除。会产生内部碎片。
    - 优点：不需要额外的空间。
    - 缺点：两次扫描，严重浪费时间。会产生内存碎片，
- 标记压缩算法：防止内存碎片产生。再次扫描，向一端移动存活的对象。多了一个移动的成本。
- 标记清除和压缩结合算法：先进行一定次数的标记清除算法，然后再标记压缩，减少移动成本，不用每次都移动。
### OOM排查
- VM参数 -Xms10m -Xmx10m -XX:+HeapDumpOnOutOfMemoryError -Xms10m -Xmx10m -XX:+HeapDumpOnClassNotFoundException
- 把OOM的文件Dump下来，用Jprofiler分析大对象所在的位置
