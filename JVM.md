# JVM面经
### JVM内存模型
JVM调优在堆中调 
- 方法区：static、final、Class类模板、常量池
- 栈：8大基本类型、对象引用、实例方法
**一个JVM只有一个堆内存。** 
- 堆Heap(HotSpot)：类、方法、常量、变量、保存我们所有引用类型的真实对象。
    - 堆分为三个区域：新生代、老年代、元空间。
    - 永久区：这个区域是常驻内存的。用来存放jdk自身携带的Class对象，interface元数据。存储的是java运行时的环境和类信息。这个区域不存在垃圾回收。关闭VM就会释放这个区域的内存。
      - jdk 1.6之前：永久代、常量池是在方法区
      - jdk1.7：永久代，但是慢慢的退化了，去永久代。常量池在堆中。方法区在堆中。
      - jdk1.8之后：无永久代，常量池在元空间中。
    - 元空间：逻辑上存在，物理上不存在。
### GC
- 初始堆内存大小为10M：默认1/64 最大堆内存大小为10M：默认1/4 
- -Xms10m -Xmx10m -Xlog:gc*           
> GC回收在伊甸园区和老年代。新生代分为伊甸园区、幸存区from、幸存区to。
**复制算法最佳使用场景：对象存活度较低。也就是新生代，所以新生代使用复制算法。**
> 年轻代主要用复制算法 from -> to 谁空谁是to区。老年代使用标记清除 + 标记压缩混合。
- 复制算法：在Eden区存活的对象存入To区，From区的对象也移动到To区，然后To区变为From区，From区变为To区。
    - 优点：没有内存碎片。
    - 缺点：浪费了内存空间。因为浪费了幸存区的to区，它一直是空着的。极端情况从from到to移动一大堆对象，就会移动的时间很长，浪费资源。
- 标记清除算法：第一次扫描，将还在使用的对象进行标记，第二次扫描，对没有标记的对象进行清除。会产生内部碎片。
    - 优点：不需要额外的空间。
    - 缺点：两次扫描，严重浪费时间。会产生内存碎片，
- 标记压缩算法：防止内存碎片产生。再次扫描，向一端移动存活的对象。多了一个移动的成本。
- 标记清除和压缩结合算法：先进行一定次数的标记清除算法，然后再标记压缩，减少移动成本，不用每次都移动。
### OOM排查
- VM参数 -Xms10m -Xmx10m -XX:+HeapDumpOnOutOfMemoryError -Xms10m -Xmx10m -XX:+HeapDumpOnClassNotFoundException
- 把OOM的文件Dump下来，用Jprofiler分析大对象所在的位置
