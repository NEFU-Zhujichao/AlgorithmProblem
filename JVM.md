# JVM面经
### JVM包括两种数据类型
- 反射，就是在运行时获取某个类的类型相关信息，如它的字段信息，方法信息，构造函数信息，父类信息，实现的接口信息。
- 基本类型：数值类型，boolean类型，和returnAddress类型
  - 数值类型包括，整型，浮点型，和char类型。boolean类型同样只有true和false。returnAddress类型是一个指针，指向jvm指令的操作码，在Java中没有与之对应的类型。
- 引用类型：类类型，数组类型，和接口类型。
### JVM内存模型
JVM调优在堆中调
> 运行时公有数据区
- 方法区：static、final、Class类模板、常量池
- 堆Heap(HotSpot)：类、方法、常量、变量、保存我们所有引用类型的真实对象。对象实例和数组都是在堆上分配的，GC 也主要对这两类数据进行回收。
    - 堆分为三个区域：新生代、老年代、元空间。
    - 元空间：这个区域是常驻内存的。用来存放jdk自身携带的Class对象，interface元数据。存储的是java运行时的环境和类信息。这个区域不存在垃圾回收。关闭VM就会释放这个区域的内存。
        - jdk 1.6之前：永久代、常量池是在方法区
        - jdk1.7：永久代，但是慢慢的退化了，去永久代。常量池在堆中。方法区在堆中。
        - jdk1.8之后：无永久代，常量池在元空间中。元空间在堆中。
    - 元空间：逻辑上存在，物理上不存在。
> 运行时私有数据区
- 栈：8大基本类型、对象引用、实例方法
- 程序寄存器：所以程序计数器的主要作用是记录线程运行时的状态，方便线程被唤醒时能从上一次被挂起时的状态继续执行，需要注意的是，程序计数器是唯一一个在 Java 虚拟机规范中没有规定任何 OOM 情况的区域，所以这块区域也不需要进行 GC
- 虚拟机栈：生命周期与线程相同,每个方法被执行的同时会创建栈桢（下文会看到），主要保存执行方法时的局部变量表、操作数栈、动态连接和方法返回地址等信息,方法执行时入栈，方法执行完出栈，出栈就相当于清空了数据，入栈出栈的时机很明确，所以这块区域不需要进行 GC。
- 本地方法栈：与虚拟机栈功能非常类似，主要区别在于虚拟机栈为虚拟机执行 Java 方法时服务，而本地方法栈为虚拟机执行本地方法时服务的。这块区域也不需要进行 GC
**一个JVM只有一个堆内存。**
### 如何识别垃圾
> 引用计数法：最容易想到的一种方式是引用计数法，啥叫引用计数法，简单地说，就是对象被引用一次，在它的对象头上加一次引用次数，如果没有被引用（引用次数为 0），则此对象可回收。看起来用引用计数确实没啥问题了，不过它无法解决一个主要的问题：循环引用！
```java
public  class TestRC {
    TestRC instance;
    public TestRC(String name) {}
    public static  void main(String[] args) {
        // 第一步
	A a = new TestRC("a");
	B b = new TestRC("b");
        // 第二步
	a.instance = b;
	b.instance = a;
        // 第三步
	a = null;
	b = null;
    }
}
```
> 可达性算法：现代虚拟机基本都是采用这种算法来判断对象是否存活，可达性算法的原理是以一系列叫做  GC Root  的对象为起点出发，引出它们指向的下一个节点，再以下个节点为起点，引出此节点指向的下一个结点。。。（这样通过 GC Root 串成的一条线就叫引用链），直到所有的结点都遍历完毕,如果相关对象不在任意一个以 GC Root 为起点的引用链中，则这些对象会被判断为「垃圾」,会被 GC 回收。
- a, b 对象可回收，就一定会被回收吗?并不是，对象的 finalize 方法给了对象一次垂死挣扎的机会，当对象不可达（可回收）时，当发生GC时，会先判断对象是否执行了 finalize 方法，如果未执行，则会先执行 finalize 方法，我们可以在此方法里将当前对象与 GC Roots 关联，这样执行 finalize 方法之后，GC 会再次判断对象是否可达，如果不可达，则会被回收，如果可达，则不回收！
- **注意**： finalize 方法只会被执行一次，如果第一次执行 finalize 方法此对象变成了可达确实不会回收，但如果对象再次被 GC，则会忽略 finalize 方法，对象会被回收！这一点切记!
- 那么这些 GC Roots 到底是什么东西呢，哪些对象可以作为 GC Root 呢，有以下几类
    - 虚拟机栈（栈帧中的本地变量表）中引用的对象
    - 方法区中类静态属性引用的对象
    - 方法区中常量引用的对象
    - 本地方法栈中 JNI（即一般说的 Native 方法）引用的对象
### GC
- 初始堆内存大小为10M：默认1/64 最大堆内存大小为10M：默认1/4 
- -Xms10m -Xmx10m -Xlog:gc*           
> GC回收在伊甸园区和老年代。新生代分为伊甸园区、幸存区from、幸存区to。
**复制算法最佳使用场景：对象存活度较低。也就是新生代，所以新生代使用复制算法。**
> 年轻代主要用复制算法 from -> to 谁空谁是to区。老年代使用标记清除 + 标记压缩混合。
- 复制算法：
    - 优点：没有内存碎片。
    - 缺点：浪费了内存空间。因为浪费了幸存区的to区，它一直是空着的。极端情况从from到to移动一大堆对象，就会移动的时间很长，浪费资源。
- 标记清除算法：第一次扫描，先根据可达性算法标记出相应的可回收对象，第二次扫描，对可回收的对象进行回收。会产生内部碎片。
    - 优点：不需要额外的空间。
    - 缺点：两次扫描，严重浪费时间。会产生内存碎片，
- 标记整理算法：防止内存碎片产生。再次扫描，向一端移动存活的对象。多了一个移动的成本。
- 分代收集算法：大部分的对象都很短命，都在很短的时间内都被回收了。所以分代收集算法根据对象存活周期的不同将堆分成新生代和老年代（Java8以前还有个永久代）,默认比例为 1 : 2，新生代又分为 Eden 区， from Survivor 区（简称S0），to Survivor 区(简称 S1),三者的比例为 8: 1 : 1，这样就可以根据新老年代的特点选择最合适的垃圾回收算法，我们把新生代发生的 GC 称为 Young GC（也叫 Minor GC）,老年代发生的 GC 称为 Old GC（也称为 Full GC）。
- 分代收集工作原理：
  - 1、对象在新生代的分配与回收：
    - **新生的对象放在Eden区，当Eden区放满之后，会触发一次轻GC。在Eden区存活的对象存入To区，From区的对象也移动到To区，然后To区变为From区，From区变为To区。To区对象年龄标记为1。**
  - 2、对象何时晋升老年代：
    - **当对象的年龄达到了我们设定的阈值(默认为15)，则会从S0（或S1）晋升到老年代**
    - **大对象 当某个对象分配需要大量的连续内存时，此时对象的创建不会分配在 Eden 区，会直接分配在老年代，因为如果把大对象分配在 Eden 区, 轻GC后再移动到S0,S1会有很大的开销（对象比较大，复制会比较慢，也占空间），也很快会占满 S0,S1 区，所以干脆就直接移到老年代**
    - **还有一种情况也会让对象晋升到老年代，即在 S0（或S1） 区相同年龄的对象大小之和大于 S0（或S1）空间一半以上时，则年龄大于等于该年龄的对象也会晋升到老年代**
  - 3、空间分配担保：在发生 MinorGC 之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象的总空间，如果大于，那么Minor GC 可以确保是安全的,如果不大于，那么虚拟机会查看 HandlePromotionFailure 设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小，如果大于则进行 Minor GC，否则可能进行一次 Full GC。
  - 4、Stop The World：如果老年代满了，会触发 Full GC, Full GC 会同时回收新生代和老年代（即对整个堆进行GC），它会导致 Stop The World（简称 STW）,造成挺大的性能开销。什么是 STW ？所谓的 STW, 即在 GC（minor GC 或 Full GC）期间，只有垃圾回收器线程在工作，其他工作线程则被挂起。
- ~~标记清除和整理结合算法：先进行一定次数的标记清除算法，然后再标记整理，减少移动成本，不用每次都移动。~~
### 垃圾收集器种类
> 如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。Java 虚拟机规范并没有规定垃圾收集器应该如何实现，因此一般来说不同厂商，不同版本的虚拟机提供的垃圾收集器实现可能会有差别，一般会给出参数来让用户根据应用的特点来组合各个年代使用的收集器，主要有以下垃圾收集器
- 在新生代工作的垃圾回收器：Serial, ParNew, ParallelScavenge
- 在老年代工作的垃圾回收器：CMS，Serial Old, Parallel Old
- 同时在新老生代工作的垃圾回收器：G1
### OOM排查
- VM参数 -Xms10m -Xmx10m -XX:+HeapDumpOnOutOfMemoryError -Xms10m -Xmx10m -XX:+HeapDumpOnClassNotFoundException
- 把OOM的文件Dump下来，用Jprofiler分析大对象所在的位置
